# Flutter Re:BLoC

A Flutter package inspired by [flutter_bloc](https://pub.dev/packages/flutter_bloc)
and reimagined to fit my own use case.

The core concept is the same and many of the implementation ideas are borrowed from that package.
The main different between this package and flutter_bloc lies in how output state and events are handled.
- There are two different events, (1) input events which I'll call actions and
  (2) internal BLoC triggered output events.
- Output events are separated from the State value itself.
  These events represent the internal happenings of the BLoC
  and state represents the application state.
  In relation to the BLoC, events are internal and state is external.
- Since events are separated, each BLoC should only stream one exact final State type.
  If you find yourself needing to use different State types,
  then creating a different BLoC to handle that State might be better.
- State can be shared with multiple BLoCs using StateProvider so
  one BLoC can access the state value generated by another BLoC.

## Usage
```dart
class CounterState extends ReBlocState {
  final int count;
  const CounterState(this.count);
}

enum CounterAction {
  increment,
  decrement
}

class CounterBloc extends ReBloc<CounterState> {
  @override
  CounterState initState() => CounterState(0);
  
  @override
  Stream<StateEvent<CounterState>> runEvent(Object action, CounterState state) async* {
    yield(StateEvent(event: 'Working...'));

    switch (action) {
      case CounterAction.increment:
        yield(StateEvent(event: 'Incremented', state: CounterState(state.count+1)));
        break;
      case CounterAction.decrement:
        yield(StateEvent(event: 'Decremented', state: CounterState(state.count-1)));
        break;
      default:
        yield(StateEvent(event: ErrorEvent(message: 'Not implemented')));
    }
  }
}

class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Counter App'),
      ),
      body: ReBlocProvider<CounterBloc, CounterState>(
        create: (context) => CounterBloc(),
        initialAction: CounterAction.increment,
        successListener: (context, event) => Scaffold.of(context).showSnackBar(
          SnackBar(
            content: Text(event.message),
          ),
        ),
        errorListener: (context, event) => Scaffold.of(context).showSnackBar(
          SnackBar(
            content: Text(event.message),
            backgroundColor: Colors.red,
          ),
        ),
        builder: (context, bloc, state) {
          return Center(
            child: Column(
              children: [
                Text(state.count.toString()),
                RaisedButton(
                  onPressed: () => bloc.add(CounterAction.increment),
                  child: const Text('Plus 1'),
                ),
                RaisedButton(
                  onPressed: () => bloc.add(CounterAction.decrement),
                  child: const Text('Minus 1'),
                ),
              ],
            ), 
          );
        }
      ),
    );
  }
}
```